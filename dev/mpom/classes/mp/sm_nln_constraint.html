<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>mp.sm_nln_constraint &mdash; MATPOWER Documentation 8.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=a5c4661c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/matpower.css?v=f6466fd7" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=bb3927b2"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script>window.MathJax = {"loader": {"load": ["[tex]/upgreek"]}, "tex": {"packages": {"[+]": ["upgreek"]}, "macros": {"dg": "\\sp\\dagger", "trans": ["{#1}^{\\mathsf{T}}", 1], "conj": ["{#1}^{\\ast}", 1], "hc": ["{#1}^{\\dg}", 1], "hconj": ["{#1}^{+}", 1], "diag": ["\\left[^\\smallsetminus{#1}_\\smallsetminus\\right]", 1], "diagg": ["\\left[\\smash{#1}\\right]", 1], "cdiag": ["\\conj{\\diag{#1}}", 1], "der": ["\\frac{\\partial{#1}}{\\partial{#2}}", 2], "dersx": ["\\frac{\\partial^2{#1}}{\\partial{#2}^2}", 2], "dersxy": ["\\frac{\\partial^2{#1}}{\\partial{#2}\\partial{#3}}", 3], "cscal": ["\\mathrm{#1}", 1], "rvec": ["{\\boldsymbol{#1}}", 1], "cvec": ["\\mathbf{#1}", 1], "rmat": ["{\\boldsymbol{#1}}", 1], "cmat": ["\\mathbf{#1}", 1], "rvecG": ["{\\boldsymbol{#1}}", 1], "cvecG": ["\\boldsymbol{#1}", 1], "rmatG": ["\\boldsymbol{\\mathit{#1}}", 1], "cmatG": ["\\mathbf{#1}", 1], "param": ["\\underline{#1}", 1], "ov": ["{\\overline{#1}}", 1], "zeros": ["\\rvec{0}", 0], "ones": ["\\rvec{1}_{#1}", 1], "onest": ["\\trans{\\rvec{1}}_{#1}", 1], "Id": ["\\diag{\\ones{#1}}", 1], "R": "\\mathbb{R}}         % requires \\usepackage{amsfonts|bbold", "C": "\\mathbb{C}}         % requires \\usepackage{amsfonts", "av": "\\cvec{a}", "bv": "\\cvec{b}", "cv": "\\cvec{c}", "f": "\\cscal{f}", "F": "\\cvec{f}", "g": "\\rvec{g}", "G": "\\cvec{g}", "h": "\\rvec{h}", "HH": "\\cvec{h}", "x": "\\rvec{x}", "y": "\\rvec{y}", "z": "\\rvec{z}", "l": "\\rvec{l}", "u": "\\rvec{u}", "c": "\\rvec{c}", "AA": "\\rmat{A}", "QQ": "\\rmat{Q}", "q": "\\rvec{q}", "X": "\\cvec{x}", "Z": "\\cvec{z}", "A": "\\cmat{A}", "B": "\\cmat{B}", "alphav": "\\rvecG{\\alpha}", "lam": "\\rvecG{\\lambda}", "lamh": "\\hat{\\lam}", "muv": "\\rvecG{\\mu}", "muhv": "\\hat{\\muv}", "vv": "\\rvec{v}", "vvi": ["\\cscal{v}_{#1}", 1], "V": "\\cvec{v}", "Vh": "\\hat{\\V}", "Vc": "\\conj{\\V}", "Vhc": "\\conj{\\Vh}", "dV": "\\diag{\\V}", "dVh": "\\diag{\\Vh}", "dVc": "\\diag{\\Vc}", "dVhc": "\\diag{\\Vhc}", "inV": "\\cvec{\\Lambda}", "inVh": "\\hat{\\inV}", "inVc": "\\conj{\\inV}", "inVhc": "\\conj{\\inVh}", "dinV": "\\diagg{\\inV}", "dinVh": "\\diagg{\\inVh}", "dinVc": "\\diagg{\\inVc}", "dinVhc": "\\diagg{\\inVhc}", "va": ["\\theta", 0], "vai": ["\\va_{#1}", 1], "Va": ["\\rvec{\\va}", 0], "Vah": ["\\hat{\\Va}", 0], "vm": ["\\nu", 0], "vmi": ["\\nu_{#1}", 1], "Vm": ["\\rvecG{\\nu}", 0], "dVm": "\\diag{\\Vm}", "dVmi": "\\dVm^{-1}", "Vmh": "\\hat{\\Vm}", "dVmh": "\\diag{\\Vmh}", "dVmhi": "\\dVmh^{-1}", "vr": "u", "vri": ["u_{#1}", 1], "vi": "w", "vii": ["w_{#1}", 1], "Vr": "\\rvec{u}", "Vi": "\\rvec{w}", "dVr": "\\diag{\\Vr}", "dVi": "\\diag{\\Vi}", "Vrh": "\\hat{\\Vr}", "Vih": "\\hat{\\Vi}", "dVrh": "\\diag{\\Vrh}", "dVih": "\\diag{\\Vih}", "E": "\\cvec{e}", "Eh": "\\hat{\\E}", "Ec": "\\conj{\\E}", "Ehc": "\\conj{\\Eh}", "dE": "\\diag{\\E}", "dEh": "\\diag{\\Eh}", "dEc": "\\diag{\\Ec}", "dEhc": "\\diag{\\Ehc}", "zr": "{z_r}", "zi": "{z_i}", "Zr": "{\\rvec{z}_r}", "Zi": "{\\rvec{z}_i}", "dlam": "\\diagg{\\lam}", "dlamh": "\\diagg{\\lamh}", "dlamva": "\\diagg{\\lam_\\va}", "dlamvm": "\\diagg{\\lam_\\vm}", "dlamvr": "\\diagg{\\lam_\\vr}", "dlamvi": "\\diagg{\\lam_\\vi}", "dlamzr": "\\diagg{\\lam_\\zr}", "dlamzi": "\\diagg{\\lam_\\zi}", "dlamhva": "\\diagg{\\lamh_\\va}", "dlamhvm": "\\diagg{\\lamh_\\vm}", "dlamhvr": "\\diagg{\\lamh_\\vr}", "dlamhvi": "\\diagg{\\lamh_\\vi}", "dlamhzr": "\\diagg{\\lamh_\\zr}", "dlamhzi": "\\diagg{\\lamh_\\zi}", "dmu": "\\diag{\\muv}", "dmuh": "\\diag{\\muhv}", "kk": "\\rvec{k}", "J": "\\param{\\rmat{J}}", "Jt": "\\trans{\\J}", "Jk": ["\\J_{\\kk_#1}", 1], "Ah": "\\hat{\\A}", "Fh": "\\hat{\\F}", "Gh": "\\hat{\\G}", "gh": "\\hat{\\g}", "fmax": "\\param{\\rvec{f}}_\\mathrm{max}", "gP": "\\g^P", "gPk": ["\\g^{P,#1}", 1], "fhmax": "\\hat{\\param{\\rvec{f}}}_\\mathrm{max}", "ghP": "\\gh^P", "ghPk": ["\\gh^{P,#1}", 1], "GS": "\\G^S", "GI": "\\G^I", "GSk": ["\\G^{S,#1}", 1], "GIk": ["\\G^{I,#1}", 1], "GSsys": "\\GSk{\\mathrm{sys}}", "GIsys": "\\GIk{\\mathrm{sys}}", "gPsys": "\\gPk{\\mathrm{sys}}", "GhS": "\\Gh^S", "GhI": "\\Gh^I", "GhSk": ["\\Gh^{S,#1}", 1], "GhIk": ["\\Gh^{I,#1}", 1], "GhSsys": "\\GhSk{\\mathrm{sys}}", "GhIsys": "\\GhIk{\\mathrm{sys}}", "ghPsys": "\\ghPk{\\mathrm{sys}}", "Ilin": "\\cvec{i}^{lin}", "Ilink": "\\cvec{i}^{lin, k}", "Ilinc": "\\conj{\\Ilin}", "dIlin": "\\diag{\\Ilin}", "dIlinc": "\\diag{\\Ilinc}", "Ilinh": "\\hat{{\\cvec{i}}}^{lin}", "Ilinhk": "\\hat{\\cvec{i}}^{lin, k}", "Ilinhc": "\\conj{\\Ilinh}", "dIlinh": "\\diag{\\Ilinh}", "dIlinhc": "\\diag{\\Ilinhc}", "Slin": "\\cvec{s}^{lin}", "Slink": "\\cvec{s}^{lin, k}", "Slinc": "\\conj{\\Slin}", "dSlin": "\\diag{\\Slin}", "dSlinc": "\\diag{\\Slinc}", "Slinh": "\\hat{\\cvec{s}}^{lin}", "Slinhk": "\\hat{\\cvec{s}}^{lin, k}", "Slinhc": "\\conj{\\Slinh}", "dSlinh": "\\diag{\\Slinh}", "dSlinhc": "\\diag{\\Slinhc}", "Inln": "\\cvec{i}^{nln}", "Inlnk": "\\cvec{i}^{nln, k}", "Snln": "\\cvec{s}^{nln}", "Snlnk": "\\cvec{s}^{nln, k}", "Inlnh": "\\hat{\\cvec{i}}^{nln}", "Inlnhk": "\\hat{\\cvec{i}}^{nln, k}", "Snlnh": "\\hat{\\cvec{s}}^{nln}", "Snlnhk": "\\hat{\\cvec{s}}^{nln, k}", "Aa": "\\param{\\rmat{A}}", "BB": "\\param{\\rmat{B}}", "CC": "\\param{\\rmat{C}}", "DD": "\\param{\\rmat{D}}", "YY": "\\param{\\cmat{Y}}", "iv": "\\param{\\cvec{i}}", "pv": "\\param{\\rvec{p}}", "sv": "\\param{\\cvec{s}}", "KK": "\\param{\\rmat{K}}", "LL": "\\param{\\cmat{L}}", "MM": "\\param{\\cmat{M}}", "NN": "\\param{\\cmat{N}}", "BBh": "\\hat{\\BB}", "YYh": "\\hat{\\YY}", "ivh": "\\hat{\\iv}", "pvh": "\\hat{\\pv}", "svh": "\\hat{\\sv}", "CCh": "\\hat{\\CC}", "KKh": "\\hat{\\KK}", "LLh": "\\hat{\\LL}", "MMh": "\\hat{\\MM}", "NNh": "\\hat{\\NN}", "AT": "\\trans{\\Aa}", "CT": "\\trans{\\CC}", "DT": "\\trans{\\DD}", "Ap": "\\Aa'", "Cp": "\\CC\\:\\!'", "Dp": "\\DD'", "ApT": "\\trans{\\Ap}", "CpT": "\\trans{\\Cp}", "DpT": "\\trans{\\Dp}", "ChT": "\\trans{\\CCh}", "Lc": "\\conj{\\LL}", "LcT": "\\trans{\\Lc}", "Lhc": "\\conj{\\LLh}", "LhcT": "\\trans{\\Lhc}", "MT": "\\trans{\\MM}", "Mc": "\\conj{\\MM}", "McT": "\\trans{\\Mc}", "dMTlam": "\\diag{\\MT \\lam}", "MhT": "\\trans{\\MMh}", "Mhc": "\\conj{\\MMh}", "MhcT": "\\trans{\\Mhc}", "dMhTlam": "\\diag{\\MhT \\lamh}", "Nc": "\\conj{\\NN}", "NcT": "\\trans{\\Nc}", "Nhc": "\\conj{\\NNh}", "NhcT": "\\trans{\\Nhc}", "YT": "\\trans{\\YY}", "Yc": "\\conj{\\YY}", "YcT": "\\trans{\\Yc}", "dYTlam": "\\diag{\\YT \\lam}", "YhT": "\\trans{\\YYh}", "Yhc": "\\conj{\\YYh}", "YhcT": "\\trans{\\Yhc}", "dYhTlam": "\\diag{\\YhT \\lamh}", "I": "\\cvec{i}^S", "s": "\\cvec{s}^I", "Ih": "\\hat{\\cvec{i}}^S", "Sh": "\\hat{\\cvec{s}}^I", "AtX": "\\AT \\X", "CtV": "\\CT \\V", "dCtV": "\\diag{\\CtV}", "DtZ": "\\DT \\Z", "ApTx": "\\ApT \\x", "CpTv": "\\CpT \\vv", "DpTz": "\\DpT \\z"}}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="mp.sm_nln_cost" href="sm_nln_cost.html" />
    <link rel="prev" title="mp.sm_lin_constraint" href="sm_lin_constraint.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #568085" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            MATPOWER Documentation
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Home</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://matpower.org">matpower.org</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Get Started</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://matpower.org/about/get-started/">Get Started</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Manuals</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../users-manual/index.html"><span class="raw-html">M<span style="font-size:smaller">ATPOWER</span></span> User’s Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../dev-manual/index.html"><span class="raw-html">M<span style="font-size:smaller">ATPOWER</span></span> Developer’s Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../ref-manual/index.html"><span class="raw-html">M<span style="font-size:smaller">ATPOWER</span></span> Reference Manual</a></li>
</ul>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../mptest/index.html">MP-Test User’s Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../mips/index.html">MIPS User’s Manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html"><span class="raw-html">MP-Opt-Model</span> User’s Manual</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../../index.html#reference">Reference</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../../reference.html">Reference</a><ul class="current">
<li class="toctree-l4 current"><a class="reference internal" href="../../reference.html#mpom-classes"><span class="raw-html">MP-Opt-Model</span> Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference.html#mpom-functions"><span class="raw-html">MP-Opt-Model</span> Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference.html#solver-interfaces-implementations">Solver Interfaces &amp; Implementations</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference.html#mpom-examples"><span class="raw-html">MP-Opt-Model</span> Examples</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference.html#mpom-tests"><span class="raw-html">MP-Opt-Model</span> Tests</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../reference.html#private-functions">Private Functions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../most/index.html">MOST User’s Manual</a></li>
</ul>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://matpower.org/doc/manuals/">All Legacy PDF Manuals</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">How To Guides</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/element.html">How to Create a New Element Type</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/add-constraint.html">How to Add an OPF Constraint</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/extension.html">How to Create an Extension</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/three-phase.html">How to Run a Three-Phase Power Flow</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../howto/builddocs.html">How to Build the Documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Tech Notes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tech-notes.html"><span class="raw-html">M<span style="font-size:smaller">ATPOWER</span></span> Technical Notes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Other Links</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://matpower.org/sponsor">Donate</a></li>
<li class="toctree-l1"><a class="reference external" href="https://matpower.org/download">Downloads</a></li>
<li class="toctree-l1"><a class="reference external" href="http://github.com/MATPOWER/matpower">GitHub Project</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #568085" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">MATPOWER Documentation</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html"><span class="raw-html">MP-Opt-Model</span> User’s Manual</a></li>
          <li class="breadcrumb-item"><a href="../../reference.html">Reference</a></li>
      <li class="breadcrumb-item active">mp.sm_nln_constraint</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/mpom/classes/mp/sm_nln_constraint.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul><div class="rst-breadcrumbs-buttons" role="navigation" aria-label="Sequential page navigation">
        <a href="sm_lin_constraint.html" class="btn btn-neutral float-left" title="mp.sm_lin_constraint" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sm_nln_cost.html" class="btn btn-neutral float-right" title="mp.sm_nln_cost" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
  </div>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <p><span class="raw-html"><div style="float: right"><a href="https://github.com/MATPOWER/mp-opt-model/blob/master/lib/+mp/sm_nln_constraint.m" target=_blank><svg height="32" aria-hidden="true" viewBox="0 0 16 16" version="1.1" width="32" data-view-component="true" class="octicon octicon-mark-github v-align-middle color-fg-default"><path d="M8 0c4.42 0 8 3.58 8 8a8.013 8.013 0 0 1-5.45 7.59c-.4.08-.55-.17-.55-.38 0-.27.01-1.13.01-2.2 0-.75-.25-1.23-.54-1.48 1.78-.2 3.65-.88 3.65-3.95 0-.88-.31-1.59-.82-2.15.08-.2.36-1.02-.08-2.12 0 0-.67-.22-2.2.82-.64-.18-1.32-.27-2-.27-.68 0-1.36.09-2 .27-1.53-1.03-2.2-.82-2.2-.82-.44 1.1-.16 1.92-.08 2.12-.51.56-.82 1.28-.82 2.15 0 3.06 1.86 3.75 3.64 3.95-.23.2-.44.55-.51 1.07-.46.21-1.61.55-2.33-.66-.15-.24-.6-.83-1.23-.82-.67.01-.27.38.01.53.34.19.73.9.82 1.13.16.45.68 1.31 2.69.94 0 .67.01 1.3.01 1.49 0 .21-.15.45-.55.38A7.995 7.995 0 0 1 0 8c0-4.42 3.58-8 8-8Z"></path></svg></a></div></span></p>
<section id="mp-sm-nln-constraint">
<h1>mp.sm_nln_constraint<a class="headerlink" href="#mp-sm-nln-constraint" title="Link to this heading"></a></h1>
<dl class="mat class">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">mp.</span></span><span class="sig-name descname"><span class="pre">sm_nln_constraint</span></span><a class="headerlink" href="#mp.sm_nln_constraint" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="set_manager_opt_model.html#mp.set_manager_opt_model" title="mp.set_manager_opt_model"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.set_manager_opt_model</span></code></a></p>
<p><a class="reference internal" href="#mp.sm_nln_constraint" title="mp.sm_nln_constraint"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_nln_constraint</span></code></a> -  MP Set Manager class for nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span> <span class="p">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">sm_nln_constraint</span><span class="p">()</span>
<span class="n">nln</span> <span class="p">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">sm_nln_constraint</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
<p>MP Set Manager class for nonlinear constraints</p>
<div class="math notranslate nohighlight" id="equation-mpom-classes-mp-sm-nln-constraint-0">
<span class="eqno">(13)<a class="headerlink" href="#equation-mpom-classes-mp-sm-nln-constraint-0" title="Link to this equation"></a></span>\[\g(\x) = 0\]</div>
<p>or</p>
<div class="math notranslate nohighlight" id="equation-mpom-classes-mp-sm-nln-constraint-1">
<span class="eqno">(14)<a class="headerlink" href="#equation-mpom-classes-mp-sm-nln-constraint-1" title="Link to this equation"></a></span>\[\g(\x) \le 0\]</div>
<p>Manages nonlinear constraint sets and their indexing.</p>
<p>By convention, <code class="docutils literal notranslate"><span class="pre">nln</span></code> (general), <code class="docutils literal notranslate"><span class="pre">nle</span></code> (equality), or <code class="docutils literal notranslate"><span class="pre">nli</span></code> (inequality)
are the variable names used for <a class="reference internal" href="#mp.sm_nln_constraint" title="mp.sm_nln_constraint"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_nln_constraint</span></code></a> objects.</p>
<dl class="simple">
<dt>mp.sm_nln_constraint Methods:</dt><dd><ul class="simple">
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.sm_nln_constraint" title="mp.sm_nln_constraint.sm_nln_constraint"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">sm_nln_constraint()</span></code></a> - constructor</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a> - add a subset of nonlinear constraints</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.params" title="mp.sm_nln_constraint.params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">params()</span></code></a> - return nonlinear constraint parameters</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.set_params" title="mp.sm_nln_constraint.set_params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">set_params()</span></code></a> - modify nonlinear constraint parameter data</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.eval" title="mp.sm_nln_constraint.eval"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">eval()</span></code></a> - evaluate individual or full set of nonlinear constraints</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.eval_hess" title="mp.sm_nln_constraint.eval_hess"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">eval_hess()</span></code></a> - evaluate “Hessian” for full set of nonlinear constraints</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.display_soln" title="mp.sm_nln_constraint.display_soln"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">display_soln()</span></code></a> - display solution values for nonlinear constraints</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.get_soln" title="mp.sm_nln_constraint.get_soln"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">get_soln()</span></code></a> - fetch solution values for specific named/indexed subsets</p></li>
<li><p><a class="reference internal" href="#mp.sm_nln_constraint.parse_soln" title="mp.sm_nln_constraint.parse_soln"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">parse_soln()</span></code></a> - parse solution for nonlinear constraints</p></li>
</ul>
</dd>
</dl>
<p>See also <a class="reference internal" href="set_manager.html#mp.set_manager" title="mp.set_manager"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.set_manager</span></code></a>, <a class="reference internal" href="set_manager_opt_model.html#mp.set_manager_opt_model" title="mp.set_manager_opt_model"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.set_manager_opt_model</span></code></a>.</p>
<div class="members docutils container">
<dl>
<dt>Constructor Summary</dt><dd><dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.sm_nln_constraint">
<span class="sig-name descname"><span class="pre">sm_nln_constraint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.sm_nln_constraint" title="Link to this definition"></a></dt>
<dd><p>Constructor.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span> <span class="p">=</span> <span class="n">mp</span><span class="p">.</span><span class="n">sm_nln_constraint</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</dd>
<dt>Method Summary</dt><dd><dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.add" title="Link to this definition"></a></dt>
<dd><p>Add a subset of nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">);</span>
<span class="n">nln</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>

<span class="n">nln</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">);</span>
<span class="n">nln</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">,</span> <span class="n">vs</span><span class="p">);</span>
</pre></div>
</div>
<p>Add a named, and possibly indexed, subset of nonlinear
constraints  <span class="math notranslate nohighlight">\(\g(\x) = 0\)</span> or <span class="math notranslate nohighlight">\(\g(\x) \le 0\)</span> to the
set, where <span class="math notranslate nohighlight">\(\x\)</span> is an <span class="math notranslate nohighlight">\(n_x \times 1\)</span> vector made up
of the variables specified in the optional <code class="docutils literal notranslate"><span class="pre">vs</span></code> <em>(in the order
given)</em>. This allows the constraint function to be defined in
terms of only the relevant variables without the need to manually
account for the locations of other variable sets.</p>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>name</strong> (<em>char array or cell array</em>) – name(s) of subset/block of
constraints to <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a></p></li>
<li><p><strong>idx_list</strong> (<em>cell array</em>) – <em>(optional)</em> index list for subset/block
of constraints to <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a> (for an indexed subset)</p></li>
<li><p><strong>N</strong> (<em>integer</em>) – number of constraints in the set, i.e. the
dimension <span class="math notranslate nohighlight">\(n\)</span> of constraint function <span class="math notranslate nohighlight">\(\g(\x)\)</span></p></li>
<li><p><strong>fcn</strong> (<em>function handle</em>) – handle to function that evaluates the
<span class="math notranslate nohighlight">\(n \times 1\)</span> constraint vector <span class="math notranslate nohighlight">\(\g(\x)\)</span>, and
optionally the corresponding <span class="math notranslate nohighlight">\(n \times n_x\)</span> Jacobian
<span class="math notranslate nohighlight">\(\g_\x = \der{\g}{\x}\)</span></p></li>
<li><p><strong>hess</strong> (<em>function handle</em>) – handle to function that evaluates the
constraint “Hessian” <span class="math notranslate nohighlight">\(\g_{\x\x}(\lam)\)</span> as
described below</p></li>
<li><p><strong>vs</strong> (<em>cell or struct array</em>) – <em>(optional, default</em> <code class="docutils literal notranslate"><span class="pre">{}</span></code> <em>)</em>
variable set defining vector <span class="math notranslate nohighlight">\(\x\)</span> for this
constraint subset; can be either a cell array of names of
variable subsets, or a struct array of <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">idx</span></code>
pairs of indexed named subsets of variables; order of
<code class="docutils literal notranslate"><span class="pre">vs</span></code> determines order of blocks in <span class="math notranslate nohighlight">\(\x\)</span>; if
empty, <span class="math notranslate nohighlight">\(\x\)</span> is assumed to be the full variable vector</p></li>
</ul>
</dd>
</dl>
<p><strong>Constraint Function Implmentation</strong> : <code class="docutils literal notranslate"><span class="pre">fcn</span></code></p>
<p>For a constraint function <span class="math notranslate nohighlight">\(\g(\x)\)</span>, the <code class="docutils literal notranslate"><span class="pre">fcn</span></code> input
should point to a function with the following interface:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">dg</span><span class="p">]</span> <span class="p">=</span> <span class="n">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list">
<dt class="field-odd">Input<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<em>double or cell array of doubles</em>) – variable <span class="math notranslate nohighlight">\(\x\)</span>
corresponding to the full variable vector, or to a set of
sub-vectors defined by the variable set provided in <code class="docutils literal notranslate"><span class="pre">vs</span></code></p>
</dd>
<dt class="field-even">Outputs<span class="colon">:</span></dt>
<dd class="field-even"><ul>
<li><p><strong>g</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times 1\)</span> constraint vector <span class="math notranslate nohighlight">\(\g(\x)\)</span></p></li>
<li><p><strong>dg</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times n_x\)</span> constraint Jacobian
<span class="math notranslate nohighlight">\(\g_\x = \der{\g}{\x}\)</span></p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The <code class="docutils literal notranslate"><span class="pre">dg</span></code> return value is the transpose of what
is expected from an input function for <a class="reference internal" href="../../functions/nlps_master.html#nlps_master" title="nlps_master"><code class="xref mat mat-func docutils literal notranslate"><span class="pre">nlps_master()</span></code></a> and
friends.</p>
</div>
</li>
</ul>
</dd>
</dl>
<p><strong>Hessian Function Implmentation</strong> : <code class="docutils literal notranslate"><span class="pre">hess</span></code></p>
<p>Similarly, the <code class="docutils literal notranslate"><span class="pre">hess</span></code> input should point to a function that
returns an <span class="math notranslate nohighlight">\(n_x \times n_x\)</span> matrix constraint “Hessian”
matrix <span class="math notranslate nohighlight">\(\g_{\x\x}(\lam)\)</span> for a given set of multipliers,
with the following interface:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d2g</span> <span class="p">=</span> <span class="nb">hess</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>double or cell array of doubles</em>) – variable <span class="math notranslate nohighlight">\(\x\)</span>
corresponding to the full variable vector, or to a set of
sub-vectors defined by the variable set provided in <code class="docutils literal notranslate"><span class="pre">vs</span></code></p></li>
<li><p><strong>lam</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times 1\)</span> vector of multipliers
<span class="math notranslate nohighlight">\(\lam\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Output<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>d2g</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n_x \times n_x\)</span> “Hessian” matrix
<span class="math notranslate nohighlight">\(\g_{\x\x}(\lam) = \der{}{\x}(\trans{\g_\x} \lam)\)</span></p>
</dd>
</dl>
<p>For both functions, the input argument <code class="docutils literal notranslate"><span class="pre">x</span></code> takes one of two
forms. If the constraint set is added with varset input <code class="docutils literal notranslate"><span class="pre">vs</span></code>
empty or missing, then <code class="docutils literal notranslate"><span class="pre">x</span></code> will be the full variable vector.
Otherwise it will be a cell array of vectors corresponding to
the variable sets specified in <code class="docutils literal notranslate"><span class="pre">vs</span></code>.</p>
<p><strong>Special Case</strong></p>
<p>For simple (not indexed) named sets, <code class="docutils literal notranslate"><span class="pre">name</span></code> can be a cell
array of constraint set names, in which case <code class="docutils literal notranslate"><span class="pre">N</span></code> is a vector
specifying the number of constraints in each corresponding set.
<code class="docutils literal notranslate"><span class="pre">fcn</span></code> and <code class="docutils literal notranslate"><span class="pre">hess</span></code> are each still a single function handle, but
the values computed by each correspond to the entire stacked
collection of constraint sets together, as if they were a single
set.</p>
<p>Likewise, if <code class="docutils literal notranslate"><span class="pre">fcn</span></code> or <code class="docutils literal notranslate"><span class="pre">hess</span></code> are empty, it indicates a
placeholder in the indexing for a constraint set whose
implementation is included in another constraint set. This
functionality is only intended to be used internally to handle
constraint/gradient and Hessian functions that compute the
values for more than one constraint set simultaneously.</p>
<p>Examples:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="c">% nonlinear equality constraint with constraint/gradient and</span>
<span class="c">% Hessian evaluation functions provided</span>
<span class="n">nle</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;var, Qmis&#39;</span><span class="p">,</span> <span class="n">nb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">);</span>

<span class="c">% nonlinear inequality constraints with indexed named set &#39;S(i,j)&#39;</span>
<span class="n">nli</span><span class="p">.</span><span class="n">init_indexed_name</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">});</span>
<span class="k">for</span> <span class="n">i</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">2</span>
  <span class="k">for</span> <span class="n">j</span> <span class="p">=</span> <span class="mi">1</span><span class="p">:</span><span class="mi">3</span>
    <span class="n">nli</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="s">&#39;S&#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">},</span> <span class="n">N</span><span class="p">{</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">},</span> <span class="mi">0</span><span class="p">,</span> <span class="p">...);</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.params" title="mp.sm_nln_constraint.params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">params()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.set_params" title="mp.sm_nln_constraint.set_params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">set_params()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.eval" title="mp.sm_nln_constraint.eval"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">eval()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.params">
<span class="sig-name descname"><span class="pre">params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.params" title="Link to this definition"></a></dt>
<dd><p>Return nonlinear constraint parameters.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">N</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">N</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">)</span>
<span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(...)</span>
<span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(...)</span>
<span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">,</span> <span class="n">vs</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(...)</span>
<span class="p">[</span><span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">,</span> <span class="n">vs</span><span class="p">,</span> <span class="n">include</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">params</span><span class="p">(...)</span>
</pre></div>
</div>
<p>Returns the parameters for the general nonlinear constraint subset
corresponding to the name or name and index list provided. The
parameters are those supplied via the add method when the
subset was added.</p>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>name</strong> (<em>char array</em>) – name of subset</p></li>
<li><p><strong>idx_list</strong> (<em>cell array</em>) – <em>(optional)</em> index list for subset</p></li>
</ul>
</dd>
<dt class="field-even">Outputs<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>N</strong> (<em>integer</em>) – number of constraints in the set, i.e. the
dimension <span class="math notranslate nohighlight">\(n\)</span> of constraint function <span class="math notranslate nohighlight">\(\g(\x)\)</span></p></li>
<li><p><strong>fcn</strong> (<em>function handle</em>) – handle to function that evaluates the
<span class="math notranslate nohighlight">\(n \times 1\)</span> constraint vector <span class="math notranslate nohighlight">\(\g(\x)\)</span>, and
optionally the corresponding <span class="math notranslate nohighlight">\(n \times n_x\)</span> Jacobian
<span class="math notranslate nohighlight">\(\g_\x = \der{\g}{\x}\)</span></p></li>
<li><p><strong>hess</strong> (<em>function handle</em>) – handle to function that evaluates the
constraint “Hessian” <span class="math notranslate nohighlight">\(\g_{\x\x}(\lam)\)</span>; see
<a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a> for details</p></li>
<li><p><strong>vs</strong> (<em>struct array</em>) – variable set, <code class="docutils literal notranslate"><span class="pre">name</span></code>, <code class="docutils literal notranslate"><span class="pre">idx</span></code> pairs
specifying the set of variables defining vector <span class="math notranslate nohighlight">\(\x\)</span>
for this cost subset; order of <code class="docutils literal notranslate"><span class="pre">vs</span></code> determines
order of blocks in <span class="math notranslate nohighlight">\(\x\)</span></p></li>
<li><p><strong>include</strong> (<em>struct</em>) – <em>(optional)</em> for constraint sets whose
functions compute the constraints for additional sets,
struct with fields:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">name</span></code> - cell array of additional set names computed</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">N</span></code> - array of corresponding dimensions</p></li>
</ul>
</li>
</ul>
</dd>
</dl>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.eval" title="mp.sm_nln_constraint.eval"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">eval()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.set_params">
<span class="sig-name descname"><span class="pre">set_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">idx</span></em>, <em class="sig-param"><span class="pre">params</span></em>, <em class="sig-param"><span class="pre">vals</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.set_params" title="Link to this definition"></a></dt>
<dd><p>Modify nonlinear constraint parameter data.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span><span class="p">.</span><span class="n">set_params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">set_params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">vals</span><span class="p">)</span>
</pre></div>
</div>
<p>This method can be used to modify parameters for an existing
subset of nonlinear constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>name</strong> (<em>char array</em>) – name of subset/block of nonlinear
constraints to modify</p></li>
<li><p><strong>idx_list</strong> (<em>cell array</em>) – <em>(optional)</em> index list for subset/block
of nonlinear constraints to modify (for an indexed subset)</p></li>
<li><p><strong>params</strong> – can be one of three options:</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">'all'</span></code> - indicates that <code class="docutils literal notranslate"><span class="pre">vals</span></code> is a cell array
whose elements correspond to the input parameters of
the <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a> method</p></li>
<li><p>name of a parameter - <code class="docutils literal notranslate"><span class="pre">val</span></code> is the value of that
parameter</p></li>
<li><p>cell array of parameter names - <code class="docutils literal notranslate"><span class="pre">vals</span></code> is a cell array
of corresponding values</p></li>
</ul>
</li>
<li><p><strong>vals</strong> – new value or cell array of new values corresponding to
<code class="docutils literal notranslate"><span class="pre">params</span></code></p></li>
</ul>
</dd>
</dl>
<p>Valid parameter names are <code class="docutils literal notranslate"><span class="pre">N</span></code>, <code class="docutils literal notranslate"><span class="pre">fcn</span></code>, <code class="docutils literal notranslate"><span class="pre">hess</span></code>, <code class="docutils literal notranslate"><span class="pre">vs</span></code>.</p>
<p>Examples:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span><span class="p">.</span><span class="n">set_params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="s">&#39;y&#39;</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">},</span> <span class="p">{</span><span class="s">&#39;fcn&#39;</span><span class="p">,</span> <span class="s">&#39;hess&#39;</span><span class="p">},</span> <span class="p">{</span><span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">});</span>
<span class="n">nln</span><span class="p">.</span><span class="n">set_params</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="s">&#39;Pmis&#39;</span><span class="p">,</span> <span class="s">&#39;all&#39;</span><span class="p">,</span> <span class="p">{</span><span class="n">N</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="nb">hess</span><span class="p">,</span> <span class="n">vs</span><span class="p">});</span>
</pre></div>
</div>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.params" title="mp.sm_nln_constraint.params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">params()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.eval">
<span class="sig-name descname"><span class="pre">eval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.eval" title="Link to this definition"></a></dt>
<dd><p>Evaluate individual or full set of nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
<span class="n">g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="nb">eval</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">)</span>
<span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">dg</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="nb">eval</span><span class="p">(...)</span>
</pre></div>
</div>
<p>For a given value of the variable vector <span class="math notranslate nohighlight">\(\x\)</span>, this method
evaluates the nonlinear constraint function and optionally its
derivatives for an individual subset, if name or name and index
list are provided, otherise, for the full set of constraints.</p>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>x</strong> (<em>double</em>) – full <span class="math notranslate nohighlight">\(n_x \times 1\)</span> variable vector <span class="math notranslate nohighlight">\(\x\)</span></p></li>
<li><p><strong>name</strong> (<em>char array</em>) – name of subset/block of nonlinear
constraints to evaluate</p></li>
<li><p><strong>idx_list</strong> (<em>cell array</em>) – <em>(optional)</em> index list for subset/block
of nonlinear constraints to evaluate (for an indexed subset)</p></li>
</ul>
</dd>
<dt class="field-even">Outputs<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>g</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times 1\)</span> constraint vector <span class="math notranslate nohighlight">\(\g(\x)\)</span></p></li>
<li><p><strong>dg</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times n_x\)</span> constraint Jacobian
<span class="math notranslate nohighlight">\(\g_\x = \der{\g}{\x}\)</span></p></li>
</ul>
</dd>
</dl>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.params" title="mp.sm_nln_constraint.params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">params()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.eval_hess">
<span class="sig-name descname"><span class="pre">eval_hess</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">x</span></em>, <em class="sig-param"><span class="pre">lam</span></em>, <em class="sig-param"><span class="pre">name</span></em>, <em class="sig-param"><span class="pre">idx</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.eval_hess" title="Link to this definition"></a></dt>
<dd><p>Evaluate “Hessian” for full set of nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">d2g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">eval_hess</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">)</span>

<span class="c">% not yet implemented</span>
<span class="n">d2g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">eval_hess</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">d2g</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">eval_hess</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx_list</span><span class="p">)</span>
</pre></div>
</div>
<p>For a given value of the variable vector <span class="math notranslate nohighlight">\(\x\)</span>, this method
evaluates the nonlinear constraint “Hessian” for the full set of
constraints.</p>
<p>Instead of evaluating the full 3 dimensional Hessian, it
actually evaluates the Jacobian of the vector formed by
multiplying the transpose of the constraint Jacobian by a
vector <span class="math notranslate nohighlight">\(\lam\)</span> of multipliers.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Evaluation of Hessian for individual subsets not yet
implemented.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>x</strong> (<em>double</em>) – full <span class="math notranslate nohighlight">\(n_x \times 1\)</span> variable vector <span class="math notranslate nohighlight">\(\x\)</span></p></li>
<li><p><strong>lam</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n \times 1\)</span> vector of multipliers
<span class="math notranslate nohighlight">\(\lam\)</span></p></li>
<li><p><strong>name</strong> (<em>char array</em>) – <em>(optional, and not yet implemented)</em> name
of subset/block of nonlinear constraints to evaluate</p></li>
<li><p><strong>idx_list</strong> (<em>cell array</em>) – <em>(optional, and not yet implemente)</em>
index list for subset/block of nonlinear constraints to
evaluate (for an indexed subset)</p></li>
</ul>
</dd>
<dt class="field-even">Outputs<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>d2g</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(n_x \times n_x\)</span> “Hessian” matrix
<span class="math notranslate nohighlight">\(\g_{\x\x}(\lam) = \der{}{\x}(\trans{\g_\x} \lam)\)</span></p>
</dd>
</dl>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.add" title="mp.sm_nln_constraint.add"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">add()</span></code></a>, <a class="reference internal" href="#mp.sm_nln_constraint.params" title="mp.sm_nln_constraint.params"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">params()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.display_soln">
<span class="sig-name descname"><span class="pre">display_soln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">soln</span></em>, <em class="sig-param"><span class="pre">iseq</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.display_soln" title="Link to this definition"></a></dt>
<dd><p>Display solution values for nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">fid</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">nln</span><span class="p">.</span><span class="n">display_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">fid</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
<p>Displays the solution values for all nonlinear constraints
(default) or an individual named or named/indexed subset.</p>
<dl class="field-list">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>soln</strong> (<em>struct</em>) – full solution struct with these fields
(among others):</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">eflag</span></code> - exit flag, 1 = success, 0 or negative =
solver-specific failure code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> - variable values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lambda</span></code> - constraint shadow prices, struct with
fields:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eqnonlin</span></code> - nonlinear equality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ineqnonlin</span></code> - nonlinear inequality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_l</span></code> - linear constraint lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_u</span></code> - linear constraint upper bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code> - variable lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper</span></code> - variable upper bounds</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><strong>iseq</strong> (<em>boolean</em>) – true for equality constraints, false for
inequality constraints</p></li>
<li><p><strong>fid</strong> (<em>fileID</em>) – fileID of open file to write to (default is
1 for standard output)</p></li>
<li><p><strong>name</strong> (<em>char array</em>) – <em>(optional)</em> name of individual subset</p></li>
<li><p><strong>idx</strong> (<em>cell array</em>) – <em>(optional)</em> indices of individual subset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.get_soln">
<span class="sig-name descname"><span class="pre">get_soln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">var</span></em>, <em class="sig-param"><span class="pre">soln</span></em>, <em class="sig-param"><span class="pre">iseq</span></em>, <em class="sig-param"><span class="pre">varargin</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.get_soln" title="Link to this definition"></a></dt>
<dd><p>Fetch solution values for specific named/indexed subsets.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">vals</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">vals</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
<span class="n">vals</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
<span class="n">vals</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">,</span> <span class="n">tags</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
</pre></div>
</div>
<p>Returns named/indexed nonlinear constraint results for a solved
model, evaluated at the solution found.</p>
<dl class="field-list">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>var</strong> (<a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a>) – corresponding <a class="reference internal" href="sm_variable.html#mp.sm_variable" title="mp.sm_variable"><code class="xref mat mat-class docutils literal notranslate"><span class="pre">mp.sm_variable</span></code></a> object</p></li>
<li><p><strong>soln</strong> (<em>struct</em>) – full solution struct with these fields
(among others):</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">eflag</span></code> - exit flag, 1 = success, 0 or negative =
solver-specific failure code</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> - variable values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lambda</span></code> - constraint shadow prices, struct with
fields:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eqnonlin</span></code> - nonlinear equality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ineqnonlin</span></code> - nonlinear inequality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_l</span></code> - linear constraint lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_u</span></code> - linear constraint upper bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code> - variable lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper</span></code> - variable upper bounds</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><strong>iseq</strong> (<em>boolean</em>) – true for equality constraints, false for
inequality constraints</p></li>
<li><p><strong>tags</strong> (<em>char array or cell array of char arrays</em>) – names of
desired outputs, default is <code class="docutils literal notranslate"><span class="pre">{'g',</span> <span class="pre">'lam',</span> <span class="pre">'dg'}</span></code> with
valid values:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">'g'</span></code> or <code class="docutils literal notranslate"><span class="pre">'h'</span></code> - constraint value <span class="math notranslate nohighlight">\(\g(\x)\)</span></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'lam'</span></code> or <code class="docutils literal notranslate"><span class="pre">'mu'</span></code> - shadow price <span class="math notranslate nohighlight">\(\lam\)</span> on
constraint</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">'dg'</span></code> or <code class="docutils literal notranslate"><span class="pre">'dh'</span></code> - constraint Jacobian
<span class="math notranslate nohighlight">\(\g_\x = \der{\g}{\x}\)</span></p></li>
</ul>
</div></blockquote>
</li>
<li><p><strong>name</strong> (<em>char array</em>) – name of the subset</p></li>
<li><p><strong>idx</strong> (<em>cell array</em>) – <em>(optional)</em> indices of the subset</p></li>
</ul>
</dd>
<dt class="field-even">Outputs<span class="colon">:</span></dt>
<dd class="field-even"><p>Variable number of outputs corresponding to <code class="docutils literal notranslate"><span class="pre">tags</span></code> input.
If <code class="docutils literal notranslate"><span class="pre">tags</span></code> is empty or not specified, the calling context
will define the number of outputs, returned in order of
default tags.</p>
</dd>
</dl>
<p>Example:</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="p">[</span><span class="n">g</span><span class="p">,</span> <span class="n">lam</span><span class="p">,</span> <span class="n">dg</span><span class="p">]</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="s">&#39;flow&#39;</span><span class="p">);</span>
<span class="n">dg_Pmis_5_3</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">get_soln</span><span class="p">(</span><span class="nb">var</span><span class="p">,</span> <span class="n">soln</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="s">&#39;dg&#39;</span><span class="p">,</span> <span class="s">&#39;Pmis&#39;</span><span class="p">,</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span><span class="mi">3</span><span class="p">});</span>
</pre></div>
</div>
<p>For a complete set of solution values, using the <a class="reference internal" href="#mp.sm_nln_constraint.parse_soln" title="mp.sm_nln_constraint.parse_soln"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">parse_soln()</span></code></a>
method may be more efficient.</p>
<p>See also <a class="reference internal" href="#mp.sm_nln_constraint.parse_soln" title="mp.sm_nln_constraint.parse_soln"><code class="xref mat mat-meth docutils literal notranslate"><span class="pre">parse_soln()</span></code></a>.</p>
</dd></dl>

<dl class="mat method">
<dt class="sig sig-object mat" id="mp.sm_nln_constraint.parse_soln">
<span class="sig-name descname"><span class="pre">parse_soln</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="pre">soln</span></em>, <em class="sig-param"><span class="pre">iseq</span></em>, <em class="sig-param"><span class="pre">stash</span></em><span class="sig-paren">)</span><a class="headerlink" href="#mp.sm_nln_constraint.parse_soln" title="Link to this definition"></a></dt>
<dd><p>Parse solution for nonlinear constraints.</p>
<div class="highlight-octave notranslate"><div class="highlight"><pre><span></span><span class="n">ps</span> <span class="p">=</span> <span class="n">nln</span><span class="p">.</span><span class="n">parse_soln</span><span class="p">(</span><span class="n">soln</span><span class="p">,</span> <span class="n">iseq</span><span class="p">)</span>
</pre></div>
</div>
<p>Parse a full solution struct into parts corresponding to
individual nonlinear constraint subsets.</p>
<dl class="field-list">
<dt class="field-odd">Inputs<span class="colon">:</span></dt>
<dd class="field-odd"><ul>
<li><p><strong>soln</strong> (<em>struct</em>) – full solution struct with these fields
(among others):</p>
<blockquote>
<div><ul>
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code> - variable values</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lambda</span></code> - constraint shadow prices, struct with
fields:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">eqnonlin</span></code> - nonlinear equality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ineqnonlin</span></code> - nonlinear inequality constraints</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_l</span></code> - linear constraint lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu_u</span></code> - linear constraint upper bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">lower</span></code> - variable lower bounds</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">upper</span></code> - variable upper bounds</p></li>
</ul>
</div></blockquote>
</li>
</ul>
</div></blockquote>
</li>
<li><p><strong>iseq</strong> (<em>boolean</em>) – true for equality constraints, false for
inequality constraints</p></li>
<li><p><strong>stash</strong> (<em>boolean</em>) – if true, store return value in <code class="xref mat mat-attr docutils literal notranslate"><span class="pre">soln</span></code>
property</p></li>
</ul>
</dd>
<dt class="field-even">Output<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ps</strong> (<em>struct</em>) – parsed solution, struct where each field listed
below is a struct whos names are the names of the relevant
nonlinear constraint subsets and values are scalars for
named sets, arrays for named/indexed sets:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">lam</span></code> - equality constraint shadow prices</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mu</span></code> - inequality constraint shadow prices</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
</dd></dl>

</dd>
</dl>
</div>
</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sm_lin_constraint.html" class="btn btn-neutral float-left" title="mp.sm_lin_constraint" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sm_nln_cost.html" class="btn btn-neutral float-right" title="mp.sm_nln_cost" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 1996-2024, Power Systems Engineering Research Center (PSERC).</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>